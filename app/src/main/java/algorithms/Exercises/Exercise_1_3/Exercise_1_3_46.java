package algorithms.Exercises.Exercise_1_3;

/**
 * Exercise 1.3.46
 * 
 * <p>
 * <i>Forbidden triple for stack generability</i>. Prove that a permutation can
 * be generated by a stack (as in the previous question) if and only if it has
 * no forbidden triple (𝑎, 𝑏, 𝑐) such that 𝑎 < 𝑏 < 𝑐 with 𝑐 first, 𝑎
 * second, and 𝑏 third (possibly with other intervening integers between 𝑐 and
 * 𝑎 and between 𝑎 and 𝑏).
 * </p>
 * 
 * <p>
 * <i>Partial solution</i>: Suppose that there is a forbidden triple (𝑎, 𝑏,
 * 𝑐). Item 𝑐 is popped before 𝑎 and 𝑏, but 𝑎 and 𝑏 are pushed before 𝑐.
 * Thus, when 𝑐 is pushed, both 𝑎 and 𝑏 are on the stack. Therefore, 𝑎
 * cannot be popped before 𝑏.
 * </p>
 * 
 * <p>
 * <i>Solution</i>: <b>(1) If a forbidden triple (𝑎, 𝑏, 𝑐) appears in the
 * permutation, then the permutation is not stack-generable.</b>
 * </p>
 * 
 * <p>
 * Suppose the output permutation contains a forbidden triple: 𝑐 appears
 * earlier than 𝑎 which appears earlier than 𝑏, and 𝑎 < 𝑏 < 𝑐. In the stack
 * process each number is pushed when it arrives (in increasing numeric order)
 * and later popped.
 * </p>
 * 
 * <p>
 * Because 𝑎 < 𝑏, the push of 𝑎 happens before the push of 𝑏. Also 𝑐 is
 * larger than both, so its push happens after both 𝑎 and 𝑏. Now in the output
 * 𝑐 appears before both 𝑎 and 𝑏; therefore 𝑐 must have been popped (and
 * output) while both 𝑎 and 𝑏 were still on the stack. In particular, at the
 * moment 𝑐 is pushed and then immediately popped, the stack contains both 𝑎
 * and 𝑏 beneath 𝑐. Since 𝑏 was pushed after 𝑎, in the stack 𝑏 is above 𝑎.
 * Thus once 𝑐 has been removed, the stack still has 𝑏 above 𝑎, so 𝑏 must be
 * popped before 𝑎. That contradicts the required order 𝑎 before 𝑏. Therefore
 * a permutation containing such a triple cannot be produced by any single-stack
 * process.
 * </p>
 * 
 * <p>
 * <b>(2) If a permutation has no forbidden triple then it is
 * stack-generable.</b>
 * </p>
 * 
 * <p>
 * We describe the standard greedy stack procedure and show it always succeeds
 * when the permutation avoids the forbidden triple pattern.
 * </p>
 * 
 * <p>
 * <b>The greedy procedure</b>. Process the input numbers 1, 2, …, 𝑛 in order,
 * pushing each onto the stack; whenever the stack top equals the next required
 * element of the target permutation, pop it to the output. Continue pushing and
 * popping until the whole target permutation is produced (or until the
 * procedure is stuck).
 * </p>
 * 
 * <p>
 * We must show: if the target permutation 𝜋 contains no forbidden triple, this
 * procedure never gets stuck and therefore produces 𝜋.
 * </p>
 * 
 * <p>
 * Assume, for contradiction, that the procedure gets stuck at the first time it
 * is required to output some value 𝑎 of 𝜋 but the top of the stack is some
 * other value 𝑏 ≠ 𝑎. (“First time” means that all earlier entries of 𝜋 have
 * already been produced.) Because values are pushed in increasing numeric
 * order, the fact that 𝑎 lies below 𝑏 in the stack implies 𝑎 < 𝑏 (push
 * order is numeric order). Also, since we are trying to output 𝑎 now, 𝑏 must
 * appear later than 𝑎 in 𝜋. So in 𝜋 we have 𝑎 before 𝑏, while in the stack
 * 𝑏 is above 𝑎 and so would be popped before 𝑎. That is exactly the conflict
 * that caused the procedure to be stuck.
 * </p>
 * 
 * <p>
 * We will now show that this deadlock would force a forbidden triple to appear
 * in 𝜋, contradicting the hypothesis that 𝜋 avoids forbidden triples.
 * </p>
 * 
 * <p>
 * Look at the moment just before we try to output 𝑎. At that moment all
 * numbers 1, 2, …, 𝑛 that are numerically ≤ the current input pointer have
 * been pushed, and some of them have been popped; the stack top is 𝑏 and
 * somewhere below it is 𝑎. Because 𝑏 sits on top of 𝑎, every number that was
 * pushed after 𝑏 must have been popped already (otherwise such a later-pushed
 * number would lie above 𝑏 on the stack). In particular, every number 𝑐 with
 * 𝑐 > 𝑏 cannot be sitting above 𝑏; if it exists it must already have been
 * popped to the output earlier than the current position. So there does exist
 * (possibly many) numbers 𝑐 with 𝑐 > 𝑏 that were popped earlier in the
 * output. Choose one such 𝑐 that was popped earliest among those > 𝑏. By
 * choice, this 𝑐 appears in 𝜋 earlier than both 𝑎 and 𝑏. We already
 * observed 𝑎 < 𝑏. Therefore the triple of values (𝑎, 𝑏, 𝑐) satisfies 𝑎 <
 * 𝑏 < 𝑐 and appears in 𝜋 in the order 𝑐 then 𝑎 then 𝑏. That is exactly a
 * forbidden triple — contradiction.
 * </p>
 * 
 * <p>
 * Thus the greedy procedure cannot get stuck, so it produces the whole
 * permutation. Hence every permutation with no forbidden triple is
 * stack-generable.
 * </p>
 * 
 * <p>
 * Combining (1) and (2) gives the desired characterization:
 * </p>
 * 
 * <p>
 * A permutation can be generated by one stack (input 1, 2, …, 𝑛) if and only
 * if it contains no triple of values 𝑎 < 𝑏 < 𝑐 that appear in the output as
 * 𝑐 then 𝑎 then 𝑏.
 * </p>
 */
public class Exercise_1_3_46 {
    public static void main(String[] args) {
    }
}
