package algorithms.Exercises.Exercise_1_3;

/**
 * Exercise 1.3.46
 * 
 * <p>
 * <i>Forbidden triple for stack generability</i>. Prove that a permutation can
 * be generated by a stack (as in the previous question) if and only if it has
 * no forbidden triple (ğ‘, ğ‘, ğ‘) such that ğ‘ < ğ‘ < ğ‘ with ğ‘ first, ğ‘
 * second, and ğ‘ third (possibly with other intervening integers between ğ‘ and
 * ğ‘ and between ğ‘ and ğ‘).
 * </p>
 * 
 * <p>
 * <i>Partial solution</i>: Suppose that there is a forbidden triple (ğ‘, ğ‘,
 * ğ‘). Item ğ‘ is popped before ğ‘ and ğ‘, but ğ‘ and ğ‘ are pushed before ğ‘.
 * Thus, when ğ‘ is pushed, both ğ‘ and ğ‘ are on the stack. Therefore, ğ‘
 * cannot be popped before ğ‘.
 * </p>
 * 
 * <p>
 * <i>Solution</i>: <b>(1) If a forbidden triple (ğ‘, ğ‘, ğ‘) appears in the
 * permutation, then the permutation is not stack-generable.</b>
 * </p>
 * 
 * <p>
 * Suppose the output permutation contains a forbidden triple: ğ‘ appears
 * earlier than ğ‘ which appears earlier than ğ‘, and ğ‘ < ğ‘ < ğ‘. In the stack
 * process each number is pushed when it arrives (in increasing numeric order)
 * and later popped.
 * </p>
 * 
 * <p>
 * Because ğ‘ < ğ‘, the push of ğ‘ happens before the push of ğ‘. Also ğ‘ is
 * larger than both, so its push happens after both ğ‘ and ğ‘. Now in the output
 * ğ‘ appears before both ğ‘ and ğ‘; therefore ğ‘ must have been popped (and
 * output) while both ğ‘ and ğ‘ were still on the stack. In particular, at the
 * moment ğ‘ is pushed and then immediately popped, the stack contains both ğ‘
 * and ğ‘ beneath ğ‘. Since ğ‘ was pushed after ğ‘, in the stack ğ‘ is above ğ‘.
 * Thus once ğ‘ has been removed, the stack still has ğ‘ above ğ‘, so ğ‘ must be
 * popped before ğ‘. That contradicts the required order ğ‘ before ğ‘. Therefore
 * a permutation containing such a triple cannot be produced by any single-stack
 * process.
 * </p>
 * 
 * <p>
 * <b>(2) If a permutation has no forbidden triple then it is
 * stack-generable.</b>
 * </p>
 * 
 * <p>
 * We describe the standard greedy stack procedure and show it always succeeds
 * when the permutation avoids the forbidden triple pattern.
 * </p>
 * 
 * <p>
 * <b>The greedy procedure</b>. Process the input numbers 1, 2, â€¦, ğ‘› in order,
 * pushing each onto the stack; whenever the stack top equals the next required
 * element of the target permutation, pop it to the output. Continue pushing and
 * popping until the whole target permutation is produced (or until the
 * procedure is stuck).
 * </p>
 * 
 * <p>
 * We must show: if the target permutation ğœ‹ contains no forbidden triple, this
 * procedure never gets stuck and therefore produces ğœ‹.
 * </p>
 * 
 * <p>
 * Assume, for contradiction, that the procedure gets stuck at the first time it
 * is required to output some value ğ‘ of ğœ‹ but the top of the stack is some
 * other value ğ‘ â‰  ğ‘. (â€œFirst timeâ€ means that all earlier entries of ğœ‹ have
 * already been produced.) Because values are pushed in increasing numeric
 * order, the fact that ğ‘ lies below ğ‘ in the stack implies ğ‘ < ğ‘ (push
 * order is numeric order). Also, since we are trying to output ğ‘ now, ğ‘ must
 * appear later than ğ‘ in ğœ‹. So in ğœ‹ we have ğ‘ before ğ‘, while in the stack
 * ğ‘ is above ğ‘ and so would be popped before ğ‘. That is exactly the conflict
 * that caused the procedure to be stuck.
 * </p>
 * 
 * <p>
 * We will now show that this deadlock would force a forbidden triple to appear
 * in ğœ‹, contradicting the hypothesis that ğœ‹ avoids forbidden triples.
 * </p>
 * 
 * <p>
 * Look at the moment just before we try to output ğ‘. At that moment all
 * numbers 1, 2, â€¦, ğ‘› that are numerically â‰¤ the current input pointer have
 * been pushed, and some of them have been popped; the stack top is ğ‘ and
 * somewhere below it is ğ‘. Because ğ‘ sits on top of ğ‘, every number that was
 * pushed after ğ‘ must have been popped already (otherwise such a later-pushed
 * number would lie above ğ‘ on the stack). In particular, every number ğ‘ with
 * ğ‘ > ğ‘ cannot be sitting above ğ‘; if it exists it must already have been
 * popped to the output earlier than the current position. So there does exist
 * (possibly many) numbers ğ‘ with ğ‘ > ğ‘ that were popped earlier in the
 * output. Choose one such ğ‘ that was popped earliest among those > ğ‘. By
 * choice, this ğ‘ appears in ğœ‹ earlier than both ğ‘ and ğ‘. We already
 * observed ğ‘ < ğ‘. Therefore the triple of values (ğ‘, ğ‘, ğ‘) satisfies ğ‘ <
 * ğ‘ < ğ‘ and appears in ğœ‹ in the order ğ‘ then ğ‘ then ğ‘. That is exactly a
 * forbidden triple â€” contradiction.
 * </p>
 * 
 * <p>
 * Thus the greedy procedure cannot get stuck, so it produces the whole
 * permutation. Hence every permutation with no forbidden triple is
 * stack-generable.
 * </p>
 * 
 * <p>
 * Combining (1) and (2) gives the desired characterization:
 * </p>
 * 
 * <p>
 * A permutation can be generated by one stack (input 1, 2, â€¦, ğ‘›) if and only
 * if it contains no triple of values ğ‘ < ğ‘ < ğ‘ that appear in the output as
 * ğ‘ then ğ‘ then ğ‘.
 * </p>
 */
public class Exercise_1_3_46 {
    public static void main(String[] args) {
    }
}
